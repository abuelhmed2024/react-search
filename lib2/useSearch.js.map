{
  "version": 3,
  "sources": ["../src/useSearch.ts"],
  "sourcesContent": ["import React, { useCallback, useState } from \"react\";\nimport { DeserializedSearchResult, DocMetadata, SearchResponse } from \"./types\";\n\nconst DEFAULT_QUERY_API_URL = \"https://api.vectara.io/v1/query\";\n\n/**\n * A hook that exposes a data fetcher.\n * This data fetcher sends a request to the supplied or default API endpoint\n * and automatically parses results before returning them to the calling hook or component.\n */\nexport const useSearch = (\n  customerId: string,\n  corpusId: string,\n  apiKey: string,\n  apiUrl: string = DEFAULT_QUERY_API_URL\n) => {\n  const [isLoading, setIsLoading] = useState(false);\n\n  const headers = React.useMemo(() => {\n    const headersInstance = new Headers();\n    headersInstance.append(\"customer-id\", customerId);\n    headersInstance.append(\"x-api-key\", apiKey);\n    headersInstance.append(\"content-type\", \"application/json\");\n    headersInstance.append(\"x-source\", \"react-search\");\n\n    return headersInstance;\n  }, [customerId, apiKey]);\n\n  const generateRequestBody = useCallback(\n    (query: string, summary?: boolean) => {\n      return JSON.stringify({\n        query: [\n          {\n            query,\n            start: 0,\n            numResults: 20,\n            corpusKey: [\n              {\n                corpusId\n              }\n            ],\n            summary: summary\n              ? [\n                  {\n                    maxSummarizedResults: 5,\n                    responseLang: \"eng\"\n                  }\n                ]\n              : undefined\n          }\n        ]\n      });\n    },\n    [corpusId]\n  );\n\n  const fetchSearchResults = async (\n    query: string,\n    summary?: boolean\n  ): Promise<{\n    searchResults: DeserializedSearchResult[];\n    summary?: string;\n  }> => {\n    setIsLoading(true);\n    const requestBody = generateRequestBody(query, summary);\n    const response = await fetch(apiUrl, {\n      headers,\n      body: requestBody,\n      method: \"POST\"\n    });\n    const responseJson = await response.json();\n    setIsLoading(false);\n\n    const results = deserializeSearchResponse(responseJson.responseSet?.[0]) ?? [];\n\n    return {\n      searchResults: compileDedupedResults(results),\n      summary: responseJson.responseSet?.[0].summary?.[0]?.text\n    };\n  };\n\n  return { fetchSearchResults, isLoading };\n};\n\nconst convertMetadataToObject = (metadata: DocMetadata[]) => {\n  const obj: Record<string, string> = {};\n  metadata.forEach((item) => {\n    obj[item.name] = item.value;\n  });\n  return obj;\n};\n\nconst parseMetadata = (rawMetadata: DocMetadata[]) => {\n  const metadata = convertMetadataToObject(rawMetadata);\n  return {\n    source: metadata.source as string,\n    url: metadata.url,\n    title: metadata.title,\n    metadata\n  };\n};\n\nconst deserializeSearchResponse = (searchResponse?: SearchResponse): Array<DeserializedSearchResult> | undefined => {\n  if (!searchResponse) return undefined;\n\n  const results: Array<DeserializedSearchResult> = [];\n  const { response: responses, document: documents } = searchResponse;\n\n  responses.forEach((response) => {\n    const { documentIndex, text: rawText } = response;\n    const { pre, post, text } = parseSnippet(rawText);\n    const document = documents[Number(documentIndex)];\n    const { id, metadata: rawMetadata } = document;\n    const { source, url, title, metadata } = parseMetadata(rawMetadata);\n\n    results.push({\n      id,\n      snippet: {\n        pre,\n        text,\n        post\n      },\n      source,\n      url,\n      title,\n      metadata\n    });\n  });\n\n  return results;\n};\n\nconst START_TAG = \"%START_SNIPPET%\";\nconst END_TAG = \"%END_SNIPPET%\";\n\nconst parseSnippet = (source: string) => {\n  const [pre, textAndPost] = source.indexOf(START_TAG) !== -1 ? source.split(START_TAG) : [\"\", source];\n  const [text, post] = textAndPost.indexOf(END_TAG) !== -1 ? textAndPost.split(END_TAG) : [textAndPost, \"\"];\n  return { pre, post, text };\n};\n\nconst compileDedupedResults = (undedupedResults: DeserializedSearchResult[]): DeserializedSearchResult[] => {\n  const listedUrls: Record<string, boolean> = {};\n  const dedupedResults: DeserializedSearchResult[] = [];\n\n  undedupedResults.forEach((result) => {\n    if (result.url) {\n      if (listedUrls[result.url]) {\n        return;\n      } else {\n        listedUrls[result.url] = true;\n      }\n    }\n\n    dedupedResults.push(result);\n  });\n\n  return dedupedResults;\n};\n"],
  "mappings": "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",
  "names": ["React", "useCallback", "useState", "DEFAULT_QUERY_API_URL", "useSearch", "customerId", "corpusId", "apiKey", "apiUrl", "isLoading", "setIsLoading", "useState", "headers", "React", "headersInstance", "generateRequestBody", "useCallback", "query", "summary", "__async", "_a", "_b", "_c", "_d", "_e", "requestBody", "responseJson", "results", "deserializeSearchResponse", "compileDedupedResults", "convertMetadataToObject", "metadata", "obj", "item", "parseMetadata", "rawMetadata", "searchResponse", "responses", "documents", "response", "documentIndex", "rawText", "pre", "post", "text", "parseSnippet", "document", "id", "source", "url", "title", "START_TAG", "END_TAG", "textAndPost", "undedupedResults", "listedUrls", "dedupedResults", "result"]
}
